1) Problem Statement

Given a sorted array of integers and a target value, find the first and last positions of the target in the array.
If the target is not found, return [-1, -1].

Intuition â€” high level

A standard binary search tells you whether a target exists and gives you one index where it occurs. 
To get the first (leftmost) occurrence or the last (rightmost) occurrence, you bias the binary search when you find the target:
To find the first occurrence: when you see the target at mid, you still continue searching to the left (because there might be an earlier occurrence).
To find the last occurrence: when you see the target at mid, you still continue searching to the right (because there might be a later occurrence).
So the idea is: run two binary searches with different tie-breaking rules.

class Interval {
    int start;
    int end;
    Interval(int s, int e) {
        start = s;
        end = e;
    }
}

Interval findFirstAndLastOccurence(int[] a, int target) {
    if(a == null || a.length == 0) 
        return new Interval(-1, -1);

    int first = findFirst(a, target);
    int last = findLast(a, target);
    return new Interval(first, last);
}

int findFirst(int[] a, int target) {
    int left = 0, right = a.length - 1;
    int result = -1;
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(a[mid] == target) {
            result = mid;
            right = mid - 1;  // keep searching left part
        } else if(a[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}

int findLast(int[] a, int target) {
    int left = 0, right = a.length - 1;
    int result = -1;
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(a[mid] == target) {
            result = mid;
            left = mid + 1;  // keep searching right part
        } else if(a[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}

2) Search Target element in Matrix:

Row-Based Binary Search Approach
Since each row is sorted, we can apply binary search independently on each row to find the target.
If there are m rows and n columns, we perform binary search m times, with each binary search taking O(log n) time.
Thus, the total time complexity is O(m log n).

Steps
Iterate through each row of the matrix.
For each row, apply binary search to check if the target exists in that row.
If the target is found in any row, return true (or the position (row, col) if needed).
If the target is not found after checking all rows, return false.

public class MatrixSearch {
    public static boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }

        int m = matrix.length;    // Number of rows
        int n = matrix[0].length; // Number of columns

        // Iterate over each row
        for (int i = 0; i < m; i++) {
            // Perform binary search on the current row
            if (binarySearchRow(matrix[i], target)) {
                return true;
            }
        }
        return false;
    }

    private static boolean binarySearchRow(int[] row, int target) {
        int left = 0;
        int right = row.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (row[mid] == target) {
                return true;
            } else if (row[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        int[][] matrix = {
            {1, 4, 7, 11},
            {2, 5, 8, 12},
            {3, 6, 9, 16}
        };
        int target = 8;
        boolean found = searchMatrix(matrix, target);
        System.out.println("Target " + target + " found: " + found); // Output: Target 8 found: true

        target = 10;
        found = searchMatrix(matrix, target);
        System.out.println("Target " + target + " found: " + found); // Output: Target 10 found: false
    }
}

3) Problem Statement
A local maximum (or local peak) in an array is an element that is greater than or equal to its neighboring elements. For a 1D array:

An element at index i is a local maximum if:
It is greater than or equal to the element at i-1 (if it exists) and
It is greater than or equal to the element at i+1 (if it exists).
Special cases:
For the first element (index 0), check only the next element.
For the last element (index n-1), check only the previous element.
The problem can be to find one local maximum, all local maxima, or determine if a local maximum exists in the array.

Sample Inputs and Outputs
Example 1: Find One Local Maximum
Input:
arr = [1, 3, 3, 2, 5, 4]

Output:
3 (at index 1 or 2, since 3 >= neighbors)

Explanation:

At index 1, 3 >= 1 (previous) and 3 >= 3 (next).
At index 2, 3 >= 3 (previous) and 3 >= 2 (next).
Either can be returned as a local maximum

public class LocalMaxima {
    public static int findOneLocalMaxima(int[] arr) {
        if (arr == null || arr.length == 0) {
            throw new IllegalArgumentException("Array is empty or null");
        }
        if (arr.length == 1) {
            return arr[0];
        }
        if (arr[0] >= arr[1]) {
            return arr[0]; // First element is local max
        }
        if (arr[arr.length - 1] >= arr[arr.length - 2]) {
            return arr[arr.length - 1]; // Last element is local max
        }

        int left = 0;
        int right = arr.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            // Check if mid is a local maximum
            boolean isGreaterThanLeft = (mid == 0 || arr[mid] >= arr[mid - 1]);
            boolean isGreaterThanRight = (mid == arr.length - 1 || arr[mid] >= arr[mid + 1]);

            if (isGreaterThanLeft && isGreaterThanRight) {
                return arr[mid]; // or return mid for index
            }
            // Move to the side with larger neighbor
            else if (mid > 0 && arr[mid - 1] > arr[mid]) {
                right = mid - 1; // Move left if left neighbor is larger
            } else {
                left = mid + 1; // Move right if right neighbor is larger or equal
            }
        }
        return -1; // Should not reach here if a local max is guaranteed
    }

    public static void main(String[] args) {
        int[] arr = {1, 3, 2, 5, 4};
        System.out.println("Local Maximum: " + findOneLocalMaxima(arr)); // Output: 3

        int[] arr2 = {1, 2, 3, 4, 5};
        System.out.println("Local Maximum: " + findOneLocalMaxima(arr2)); // Output: 5
    }
}
