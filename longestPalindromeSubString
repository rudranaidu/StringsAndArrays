public class LongestPalindromeString {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String palindromeOne = findLongestPalindromeSubString("abba");
		String palindromeTwo = findLongestPalindromeSubString("abcbd");
		System.out.println(palindromeOne);
		System.out.println(palindromeTwo);

	}
	
	private static String findLongestPalindromeSubString(String input) {
		if (input == null || input.length() == 0) {
			throw new IllegalArgumentException("Please provide valid input");
		}

		int start = 0;
		int end = 0;

		for (int i = 0; i < input.length() - 1; i++) {
			int len1 = expandAroundCenter(input, i, i);
			int len2 = expandAroundCenter(input, i, i + 1);
			int len = Math.max(len1, len2);

			if (len > end - start) {
				start = i - (len - 1) / 2;
				end = i + len / 2;			}
		}
		return input.substring(start, end + 1);
	}

	private static int expandAroundCenter(String input, int left, int right) {
		int n = input.length();
		while (left > 0 && right < n && input.charAt(left) == input.charAt(right)) {
			left--;
			right++;
		}
		return right - left - 1;
	}
}


         Longest Palindromic Substring
                     │
        ┌────────────┴────────────┐
        │                         │
      Centers                   Expansion
        │                         │
   ┌────┴────┐             ┌──────┴──────┐
 Odd-length  Even-length   Left & Right pointers
  i to i      i to i+1     Expand while s[L]==s[R]
        │                         │
   Update maxLength        Calculate length = R-L-1
        │                         │
  Update start & end indices
        │
   Return s.substring(start, end+1)


Quick Mental Trick

Think “centered palindrome” – every palindrome has a center.

Check odd and even lengths at each center.

Expand as far as you can, then update start and end.

Substring from start to end is your answer.
