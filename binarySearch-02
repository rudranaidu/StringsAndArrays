
Rotate the array based on pivot element

A rotated sorted array is an array that was initially sorted in ascending (or descending) order and then rotated (shifted) at 
some pivot point so that elements after the pivot move to the beginning and those before the pivot move to the end
Efficient way to rotate at pivot k

1. Example Input/Output
Input (sorted array):
[10, 20, 30, 40, 50]

Input (rotated at pivot 2 [30]):
[40, 50, 10, 20, 30]

2. Another Example
Input (sorted array):
[1, 2, 3, 4, 5, 6]

Input (rotated at pivot 4 [5]):
[6, 1, 2, 3, 4, 5]

void rotateArray(int[] arr, int k) {
    int n = arr.length;
    // Step 1: Reverse the first part (0 to k)
    reverse(arr, 0, k);
    // Step 2: Reverse the second part (k+1 to n-1)
    reverse(arr, k+1, n-1);
    // Step 3: Reverse the whole array (0 to n-1)
    reverse(arr, 0, n-1);
}

void reverse(int[] arr, int start, int end) {
    while(start < end) {
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        start++;
        end--;
    }
}

Rotated sorted array

Problem Statement:
Given an array of distinct integers that was initially sorted in ascending order, but then rotated at some unknown pivot, and a target integer,
write an algorithm to find the index of the target in the array. If the target is not present, return -1.



The algorithm must run in O(log n) time.

Details:
The input array may look like [4,5,6,7,0,1,2] -- a sorted array [0,1,2,4,5,6,7] rotated at index 4.
You may assume all elements are unique.
If the target exists in the array, return its index.
Otherwise, return -1

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

public class FindTargetInRoatedSortedArray {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[]a = {8,9,1,2,3,4,5,6,7};
		int targetIndex = getTargetIndex(a, 1);
		System.out.println("Target index is :" + targetIndex);
	}
	
	private static int getTargetIndex(int[] a, int target) {
		int left = 0;
		int right = a.length - 1;

		while (left < right) {
			int mid = left + right - left / 2;
			if (a[mid] == target) {
				return mid;
			}

			if (a[left] <= a[mid]) {
				if (a[left] <= target && target < a[mid]) {
					right = mid - 1;
				} else {
					left = mid + 1;
				}
			} else {
				if (a[mid] < target && target <= a[right]) {
					left = mid + 1;
				} else {
					right = mid - 1;
				}
			}
		}
		return -1;
	}
}


Median of two sorted arrays

Problem Statement:
Given two sorted arrays, find the median value after merging them into a single sorted array.
The overall run time complexity should be O(log(min(n, m))) where n and m are the sizes of the arrays.

input:
nums1 = [1, 2]
nums2 = [3, 4]

Output:
2.5

Explanation:
The merged array is [1, 2, 3, 4]. The median is the average of 2 and 3, so (2 + 3)/2 = 2.5.

public class MergeTwoSortedArrays {

	public static void main(String[] args) {

		int[] a = { 1, 2, 3, 4, 5 };
		int[] b = { 6, 7, 8 };
		int[] result = mergeTwoSortedArrays(a, b);
		int reslutLen = result.length;
		int mid = reslutLen / 2;
		if (reslutLen % 2 != 0) {
			System.out.println("Median is: " + result[mid]);
		} else {
			int median = result[mid] + result[mid - 1] / 2;
			System.out.println("Median is :" + median);
		}

	}

	private static int[] mergeTwoSortedArrays(int[] a, int[] b) {

		int len1 = a.length;
		int len2 = b.length;
		int[] result = new int[len1 + len2];
		int ptr1 = 0;
		int ptr2 = 0;
		int ptr3 = 0;
		while (ptr1 < len1 && ptr2 < len2) {
			if (a[ptr1] < b[ptr2]) {
				result[ptr3++] = a[ptr1];
				ptr1++;
			} else {
				result[ptr3++] = b[ptr2];
				ptr2++;
			}

		}
		while (ptr1 < len1) {
			result[ptr3++] = a[ptr1++];
		}

		while (ptr1 < len1) {
			result[ptr3++] = b[ptr2++];
		}
		return result;
	}
}

