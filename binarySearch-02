
Rotate the array based on pivot element

A rotated sorted array is an array that was initially sorted in ascending (or descending) order and then rotated (shifted) at 
some pivot point so that elements after the pivot move to the beginning and those before the pivot move to the end
Efficient way to rotate at pivot k

1. Example Input/Output
Input (sorted array):
[10, 20, 30, 40, 50]

Input (rotated at pivot 2 [30]):
[40, 50, 10, 20, 30]

2. Another Example
Input (sorted array):
[1, 2, 3, 4, 5, 6]

Input (rotated at pivot 4 [5]):
[6, 1, 2, 3, 4, 5]

void rotateArray(int[] arr, int k) {
    int n = arr.length;
    // Step 1: Reverse the first part (0 to k)
    reverse(arr, 0, k);
    // Step 2: Reverse the second part (k+1 to n-1)
    reverse(arr, k+1, n-1);
    // Step 3: Reverse the whole array (0 to n-1)
    reverse(arr, 0, n-1);
}

void reverse(int[] arr, int start, int end) {
    while(start < end) {
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        start++;
        end--;
    }
}

Rotated sorted array

Problem Statement:
Given an array of distinct integers that was initially sorted in ascending order, but then rotated at some unknown pivot, and a target integer, write an algorithm to find the index of the target in the array. If the target is not present, return -1.

The algorithm must run in O(log n) time.

Details:
The input array may look like [4,5,6,7,0,1,2] -- a sorted array [0,1,2,4,5,6,7] rotated at index 4.
You may assume all elements are unique.
If the target exists in the array, return its index.
Otherwise, return -1

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

public class FindTargetInRoatedSortedArray {
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[]a = {8,9,1,2,3,4,5,6,7};
		int targetIndex = getTargetIndex(a, 1);
		System.out.println("Target index is :" + targetIndex);
	}
	
	private static int getTargetIndex(int[] a, int target) {
		int left = 0;
		int right = a.length - 1;

		while (left < right) {
			int mid = left + right - left / 2;
			if (a[mid] == target) {
				return mid;
			}

			if (a[left] <= a[mid]) {
				if (a[left] <= target && target < a[mid]) {
					right = mid - 1;
				} else {
					left = mid + 1;
				}
			} else {
				if (a[mid] < target && target <= a[right]) {
					left = mid + 1;
				} else {
					right = mid - 1;
				}
			}
		}
		return -1;
	}
}
